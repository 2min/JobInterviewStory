/// <reference path="../node_modules/definitely-typed-jquery/jquery.d.ts" />
/// <reference path="game.ts" />
/// <reference path="npcs.ts" />
/// <reference path="player.ts" />
/// <reference path="sounds.ts" />
var Stage = (function () {
    function Stage() {
        this.collisionsMap = [];
        this.height = 0;
        this.npcsMap = [];
        this.playersMap = [];
        this.portalsMap = [];
        this.tileMap = {
            height: 50,
            width: 50
        };
        this.width = 0;
    }
    Stage.prototype.center = function () {
        var left = 0;
        var playerPos = player.pc.position();
        var stageObject = $('#stage');
        var top = 0;
        var windowHeight = $(window).height();
        var windowWidth = $(window).width();
        left = (windowWidth / 2) - (playerPos.left + (player.pc.width() / 2));
        top = (windowHeight / 2) - (playerPos.top + ((player.pc.height() + 8) / 2));
        if (this.width <= windowWidth && this.height <= windowHeight) {
            left = (windowWidth - this.width) / 2;
            top = (windowHeight - this.height) / 2;
        }
        if (this.width > windowWidth && stageObject.offset().left > 0 && playerPos.left < windowWidth
            && this.height > windowHeight && stageObject.offset().top > 0 && playerPos.top < windowHeight) {
            left = 0;
            top = 0;
        }
        stageObject.css({
            height: this.height,
            left: left + 'px',
            top: top + 'px',
            width: this.width
        });
    };
    Stage.prototype.checkButtons = function () {
        // Shift
        if (game.pressedKeys[16]) {
        }
        // Spacebar, Enter
        if (game.pressedKeys[13] || game.pressedKeys[32]) {
        }
        switch (true) {
            // W, Up Arrow
            case ((game.pressedKeys[87] || game.pressedKeys[38])):
                break;
            // S, Down Arrow
            case ((game.pressedKeys[83] || game.pressedKeys[40])):
                break;
            // A, Left Arrow
            case ((game.pressedKeys[65] || game.pressedKeys[37])):
                break;
            // D, Right Arrow
            case ((game.pressedKeys[68] || game.pressedKeys[39])):
                break;
            default:
                break;
        }
    };
    Stage.prototype.cleanup = function () {
        var npcs = $('.npc');
        this.collisionsMap = [];
        this.npcsMap = [];
        this.playersMap = [];
        this.portalsMap = [];
        for (var i = 0; i < npcs.length; i++) {
            $(npcs[i]).data('npc').destroy();
        }
        player.destroy();
        $('#collisions').html('');
        // (<JQuery>$('#modals')).html('');
        $('#objects').html('');
        $('#tiles').html('');
        $(document).trigger('keyup');
    };
    Stage.prototype.drawCollisions = function (collisions) {
        var counter = 0;
        var height = collisions.height;
        var row = 0;
        var width = collisions.width;
        for (var i = 0; i < collisions.data.length; i++) {
            var data = collisions.data[i];
            if (!this.collisionsMap[row]) {
                this.collisionsMap[row] = {};
            }
            this.collisionsMap[row][counter] = data === 2;
            if (data !== 0) {
                $('#collisions').append('<div class="collision" ' +
                    'style="left: ' + (counter * game.gridCellSize) + 'px; top: ' + (row * game.gridCellSize) + 'px">' +
                    '</div>');
            }
            counter += (i + 1) % width === 0 ? -counter : 1;
            row += (i + 1) % width === 0 ? 1 : 0;
        }
    };
    Stage.prototype.drawObjects = function (objects) {
        for (var i = 0; i < objects.objects.length; i++) {
            var object = objects.objects[i];
            switch (object.type) {
                case 'player':
                    player.create(object);
                    break;
                case 'npc':
                    npcs.create(object);
                    break;
                case 'doorway':
                    $('#objects').append('<div id="' + object.name + '" ' +
                        'class="object doorway" ' +
                        'area="' + object.properties.area + '" ' +
                        'style="left: ' + object.x + 'px; top: ' + (object.y - game.gridCellSize) + 'px">' +
                        '</div>');
                    if (!this.portalsMap[(object.y / game.gridCellSize) - 1]) {
                        this.portalsMap[(object.y / game.gridCellSize) - 1] = {};
                    }
                    this.portalsMap[(object.y / game.gridCellSize) - 1][(object.x / game.gridCellSize)] = $('#' + object.name);
                    break;
                case 'stairs':
                    $('#objects').append('<div id="' + object.name + '" ' +
                        'class="object stairs" ' +
                        'area="' + object.properties.area + '" ' +
                        'direction="' + object.properties.direction + '" ' +
                        'style="left: ' + object.x + 'px; top: ' + (object.y - game.gridCellSize) + 'px">' +
                        '</div>');
                    if (!this.portalsMap[(object.y / game.gridCellSize) - 1]) {
                        this.portalsMap[(object.y / game.gridCellSize) - 1] = {};
                    }
                    this.portalsMap[(object.y / game.gridCellSize) - 1][(object.x / game.gridCellSize)] = $('#' + object.name);
                    break;
            }
        }
    };
    Stage.prototype.drawTiles = function (tiles) {
        var counter = 0;
        var height = tiles.height;
        var row = 0;
        var width = tiles.width;
        for (var i = 0; i < tiles.data.length; i++) {
            var tile = tiles.data[i];
            var y = Math.ceil(tile / this.tileMap.width);
            var x = (tile - ((y - 1) * this.tileMap.width));
            if (tile !== 0) {
                $('#tiles').append('<div class="tile t' + tile + ' ' + tiles.name + '" ' +
                    'style="background-position: -' + ((x * game.gridCellSize) - game.gridCellSize) + 'px -' + ((y * game.gridCellSize) - game.gridCellSize) + 'px; left: ' + (counter * game.gridCellSize) + 'px; top: ' + (row * game.gridCellSize) + 'px">' +
                    '</div>');
            }
            counter += (i + 1) % width === 0 ? -counter : 1;
            row += (i + 1) % width === 0 ? 1 : 0;
        }
    };
    Stage.prototype.init = function (stageID) {
        var _this = this;
        var transition = $('#transition');
        transition.animate({
            opacity: 1
        }, 180, 'linear', function () {
            _this.cleanup();
            game.loading = true;
            $.ajax({
                // cache: false, // For development purposes
                dataType: 'json',
                type: 'GET',
                url: '../json/' + stageID + '.json'
            }).done(function (data, textStatus, jqXHR) {
                game.prevArea = game.currentArea;
                game.currentArea = stageID;
                _this.height = data.height * game.gridCellSize;
                _this.width = data.width * game.gridCellSize;
                for (var i = 0; i < data.layers.length; i++) {
                    var layer = data.layers[i];
                    switch (true) {
                        // Collisions
                        case (layer.name === 'collisions'):
                            _this.drawCollisions(layer);
                            break;
                        // Objects
                        case (layer.type === 'objectgroup'):
                            _this.drawObjects(layer);
                            break;
                        // Tile Layer
                        default:
                            _this.drawTiles(layer);
                            break;
                    }
                }
                for (var j = 0; j < $('#player, .npc, .object, .tiles3').length; j++) {
                    game.calculateZindex($('#player, .npc, .object, .tiles3').eq(j));
                }
                _this.center();
                game.loading = false;
                if (data.properties.music
                    && (!sounds.currentMusic || sounds.currentMusic.src != sounds.music[data.properties.music])) {
                    sounds.currentMusicId = data.properties.music;
                    sounds.changeMusic(sounds.music[data.properties.music]);
                }
                sounds.fade(sounds.currentMusic, data.properties.musicVol);
                transition.animate({
                    opacity: 0
                }, 180);
            }).fail(function (jqXHR, textStatus, errorThrown) {
                // Do nothing
            }).always(function (data, textStatus, jqXHR) {
                // Do nothing
            });
        });
    };
    Stage.prototype.scrollStage = function (direction) {
        var playerOff = player.pc.offset();
        var offset = 0;
        var scrollArea = $('#scroll-area');
        var stageObject = $('#stage');
        var stagePos = stageObject.position();
        var stageL = stagePos.left;
        var stageT = stagePos.top;
        var windowH = $(window).height();
        var windowW = $(window).width();
        if ((this.width > windowW || this.height > windowH)) {
            switch (direction) {
                // Up
                case game.directions.up:
                    if ((playerOff.top + (game.gridCellSize / 2)) < (windowH / 2) && stageT < 0) {
                        stageObject.stop().animate({
                            top: stageT + game.gridCellSize + offset
                        }, 180, 'linear');
                    }
                    break;
                // Down
                case game.directions.down:
                    if ((playerOff.top + (game.gridCellSize / 2)) > (windowH / 2)
                        && Math.abs(stageT - windowH) < this.height) {
                        stageObject.stop().animate({
                            top: stageT - game.gridCellSize + offset
                        }, 180, 'linear');
                    }
                    break;
                // Left
                case game.directions.left:
                    if ((playerOff.left + (game.gridCellSize / 2)) < (windowW / 2) && stageL < 0) {
                        stageObject.stop().animate({
                            left: stageL + game.gridCellSize + offset
                        }, 180, 'linear');
                    }
                    break;
                // Right
                case game.directions.right:
                    if ((playerOff.left + (game.gridCellSize / 2)) > (windowW / 2)
                        && Math.abs(stageL - windowW) < this.width) {
                        stageObject.stop().animate({
                            left: stageL - game.gridCellSize + offset
                        }, 180, 'linear');
                    }
                    break;
            }
        }
    };
    return Stage;
})();
var stage = new Stage();
;
/// <reference path="../node_modules/definitely-typed-jquery/jquery.d.ts" />
/// <reference path="game.ts" />
/// <reference path="npcs.ts" />
/// <reference path="player.ts" />
/// <reference path="stage.ts" />
var Sounds = (function () {
    function Sounds() {
        this.domain = location.protocol + '//' + location.host;
        this.fx = {
            bip: new Audio(this.domain + '/sounds/bip.wav'),
            bump: new Audio(this.domain + '/sounds/bump.wav'),
            door: new Audio(this.domain + '/sounds/door.wav'),
            enter: new Audio(this.domain + '/sounds/enter.wav'),
            error: new Audio(this.domain + '/sounds/error.wav')
        };
        this.music = {
            shadesOfRed: this.domain + '/sounds/Pokemon_Red_Version_Shades_of_Red_OC_ReMix.mp3',
            wetDreams: this.domain + '/sounds/Pokemon_Blue_Version_Wet_Dreams_OC_ReMix.mp3'
        };
    }
    Sounds.prototype.changeMusic = function (newMusic) {
        var _this = this;
        if (this.currentMusic) {
            this.fade(this.currentMusic, 0, function () {
                _this.currentMusic.pause();
            });
        }
        game.loading = true;
        this.currentMusic = new Audio(newMusic);
        this.currentMusic.canplaythrough = this.playMusic();
    };
    Sounds.prototype.fade = function (sound, volume, callback) {
        var offset = 0.0001;
        var steps = Math.abs(sound.volume - volume) / 0.0001;
        if (sound.volume > volume) {
            offset = -0.0001;
        }
        for (var i = 1; i <= steps; i++) {
            sound.volume += offset;
        }
        if (callback) {
            callback();
        }
    };
    Sounds.prototype.playMusic = function () {
        game.loading = false;
        this.currentMusic.loop = true;
        this.currentMusic.play();
        // modals.create(
        //     {
        //         height: 16,
        //         width: '25%'
        //     },
        //     {
        //         left: 20 + 3, // The 3 is half the border-image-outset value
        //         top: (<JQuery>$(window)).height() - 68 - 3 // The 3 is half the border-image-outset value
        //     },
        //     Dialogue[this.currentMusicId]
        // );
    };
    return Sounds;
})();
var sounds = new Sounds();
/// <reference path="../node_modules/definitely-typed-jquery/jquery.d.ts" />
/// <reference path="game.ts" />
/// <reference path="npcs.ts" />
/// <reference path="sounds.ts" />
/// <reference path="stage.ts" />
var Player = (function () {
    function Player() {
        this.allowMove = true;
        this.allowPress = true;
        this.speedMultiplier = 1;
    }
    Player.prototype.checkButtons = function () {
        if (this.pc.length === 0 || !this.allowPress) {
            return;
        }
        var pcSprite = $('#player-sprite');
        this.speedMultiplier = 1;
        // Shift
        if (game.pressedKeys[16]) {
            this.speedMultiplier = 2;
        }
        // Spacebar, Enter
        if (game.pressedKeys[13] || game.pressedKeys[32]) {
            var collision = game.checkCollisions(this.pc, this.direction);
            this.allowPress = false;
            if (collision) {
                switch (true) {
                    case (collision):
                        // Do nothing
                        break;
                    case (collision.is('.npc')):
                        // collision.npc('talk', Dialogue[collision.data('npc')['dialogueId']]);
                        break;
                }
            }
        }
        switch (true) {
            // W, Up Arrow
            case ((game.pressedKeys[87] || game.pressedKeys[38])):
                this.direction = game.directions.up;
                this.pc.data('pc').move(this.direction);
                break;
            // S, Down Arrow
            case ((game.pressedKeys[83] || game.pressedKeys[40])):
                this.direction = game.directions.down;
                this.pc.data('pc').move(this.direction);
                break;
            // A, Left Arrow
            case ((game.pressedKeys[65] || game.pressedKeys[37])):
                this.direction = game.directions.left;
                this.pc.data('pc').move(this.direction);
                break;
            // D, Right Arrow
            case ((game.pressedKeys[68] || game.pressedKeys[39])):
                this.direction = game.directions.right;
                this.pc.data('pc').move(this.direction);
                break;
            default:
                pcSprite.removeClass('walking');
                break;
        }
    };
    Player.prototype.create = function (data) {
        if (data.properties.prevArea === game.prevArea) {
            var pc = $('<div id="player" style="left: ' + data.x + 'px; top: ' + (data.y - 32) + 'px;">' +
                '<div id="player-sprite" class="' + game.currentDirection + '"></div>' +
                '</div>');
            $('#objects').append(pc);
            this.pc = pc;
            pc.data('pc', this);
            if (!stage.playersMap[(data.y / game.gridCellSize) - 1]) {
                stage.playersMap[(data.y / game.gridCellSize) - 1] = {};
            }
            stage.playersMap[(data.y / game.gridCellSize) - 1][(data.x / game.gridCellSize)] = this.pc;
        }
    };
    Player.prototype.destroy = function () {
        if (this.pc) {
            this.pc.remove();
        }
        this.allowMove = true;
        this.allowPress = true;
        this.pc = null;
        this.speedMultiplier = 1;
    };
    Player.prototype.move = function (direction) {
        var _this = this;
        if (this.pc.length === 0 || !this.allowMove) {
            return;
        }
        var collision = game.checkCollisions(this.pc, direction);
        var pcPosition = game.getCoordinates(this.pc);
        var pcSprite = $('#player-sprite');
        game.currentDirection = direction;
        pcSprite.removeClass()
            .addClass('walking ' + direction);
        if (collision) {
            switch (true) {
                // Not Doorway or Stairs
                case (collision):
                    pcSprite.removeClass('walking');
                    sounds.fx.bump.play();
                    break;
                // Doorway
                case (collision.is('.doorway')):
                    this.allowMove = false;
                    sounds.fx.door.play();
                    game.moveObject(this.pc, direction, function () {
                        var newPos = game.getCoordinates(_this.pc);
                        if (!stage.playersMap[newPos.y]) {
                            stage.playersMap[newPos.y] = {};
                        }
                        stage.playersMap[newPos.y][newPos.x] = _this.pc;
                        sounds.fx.enter.play();
                        delete stage.playersMap[pcPosition.y][pcPosition.x];
                        stage.init(collision.attr('area'));
                    });
                    break;
                // Stairs
                case (collision.is('.stairs')):
                    this.allowMove = false;
                    sounds.fx.enter.play();
                    this.useStairs(collision.attr('direction'), function () {
                        stage.init(collision.attr('area'));
                    });
                    break;
            }
            ;
        }
        else {
            this.allowMove = false;
            game.moveObject(this.pc, direction, function () {
                var newPos = game.getCoordinates(_this.pc);
                _this.allowMove = true;
                if (!stage.playersMap[newPos.y]) {
                    stage.playersMap[newPos.y] = {};
                }
                stage.playersMap[newPos.y][newPos.x] = _this.pc;
                delete stage.playersMap[pcPosition.y][pcPosition.x];
            });
            stage.scrollStage(direction);
        }
    };
    Player.prototype.useStairs = function (direction, callback) {
        var pcPosition = this.pc.position();
        var offsetLeft = 0;
        var offsetTop = 0;
        switch (direction) {
            // Down & Left
            case 'dl':
                offsetLeft = -32;
                offsetTop = 0; // Player clips through the stairs if set to 32
                break;
            // Down & Right
            case 'dr':
                offsetLeft = 32;
                offsetTop = 32;
                break;
            // Up & Left
            case 'ul':
                offsetLeft = -32;
                offsetTop = -32;
                break;
            // Up & Right
            case 'ur':
                offsetLeft = 32;
                offsetTop = -32;
                break;
        }
        this.pc.addClass('walking')
            .stop()
            .animate({
            left: pcPosition.left + offsetLeft,
            top: pcPosition.top + offsetTop
        }, 180, 'linear', function () {
            if (typeof callback === 'function') {
                callback();
            }
        });
    };
    return Player;
})();
var player = new Player();
/// <reference path="../node_modules/definitely-typed-jquery/jquery.d.ts" />
/// <reference path="game.ts" />
/// <reference path="player.ts" />
/// <reference path="sounds.ts" />
/// <reference path="stage.ts" />
var NPCs = (function () {
    function NPCs() {
        this.dialogueId = 'd000';
        this.id = 0;
        this.talking = false;
        this.wanderPause = false;
    }
    NPCs.prototype.create = function (data) {
        var npc;
        $('#objects').append('<div id="' + data.name + '" class="npc">' +
            '<div class="npc-sprite"></div>' +
            '</div>');
        npc = $('#' + data.name);
        npc.data('npc', new NPCs());
        npc.data('npc').dialogueId = data.properties.dialogue;
        npc.data('npc').id = data.name;
        npc.data('npc').npc = npc;
        npc.css({
            left: data.x + 'px',
            top: (data.y - game.gridCellSize) + 'px'
        });
        if (!stage.npcsMap[(data.y / game.gridCellSize) - 1]) {
            stage.npcsMap[(data.y / game.gridCellSize) - 1] = {};
        }
        stage.npcsMap[(data.y / game.gridCellSize) - 1][(data.x / game.gridCellSize)] = npc;
        if (data.properties.wander) {
            npc.data('npc').wander();
        }
    };
    ;
    NPCs.prototype.destroy = function () {
        clearInterval(this.wanderInterval);
        if (this.npc) {
            this.npc.remove();
        }
    };
    NPCs.prototype.destroyEmote = function () {
        var _this = this;
        this.npc.find('.emote')
            .animate({
            opacity: 0,
            top: '-48px'
        }, 100, 'linear', function () {
            $(_this).remove();
        });
    };
    NPCs.prototype.emote = function (emotion) {
        var emote = this.npc.find('.emote');
        if (emote.length === 0) {
            this.npc.append('<div class="emote ' + emotion + '" style="opacity: 0; top: -48px"></div>');
            this.npc.find('.emote')
                .animate({
                opacity: 1,
                top: '-32px'
            }, 100, 'linear');
        }
        else {
            this.npc.find('.emote')
                .replaceWith('<div class="emote ' + emotion + '"></div>');
        }
    };
    NPCs.prototype.move = function (direction) {
        var _this = this;
        var collision = game.checkCollisions(this.npc, direction);
        var npcPos = game.getCoordinates(this.npc);
        var npcSprite = this.npc.find('.npc-sprite');
        game.currentDirection = direction;
        npcSprite.removeClass('walking up down left right')
            .addClass('walking ' + direction);
        if (collision) {
            npcSprite.removeClass('walking');
        }
        else {
            game.moveObject(this.npc, direction, function () {
                var newPos = game.getCoordinates(_this.npc);
                if (!stage.npcsMap[newPos.y]) {
                    stage.npcsMap[newPos.y] = {};
                }
                stage.npcsMap[newPos.y][newPos.x] = _this.npc;
                delete stage.npcsMap[npcPos.y][npcPos.x];
                npcSprite.removeClass('walking');
            });
        }
    };
    NPCs.prototype.talk = function (dialogue) {
        if (this.talking) {
            return;
        }
        this.talking = true;
        this.wanderPause = true;
        game.activeNPC = this.npc;
        // $.modals.create(
        //     {
        //         height  : 80,
        //         width   : 720
        //     },
        //     {
        //         left    : ((<JQuery>$(window)).width() - (720 + game.gridCellSize)) / 2,
        //         top     : 20
        //     },
        //     dialogue,
        //     this.npc
        // );
    };
    NPCs.prototype.wander = function () {
        var _this = this;
        clearInterval(this.wanderInterval);
        this.wanderInterval = setInterval(function () {
            var direction = game.directions[Object.keys(game.directions)[Math.floor(Math.random() * Object.keys(game.directions).length)]];
            if (Math.random() < 0.5 || _this.wanderPause === true) {
                return;
            }
            _this.move(direction);
        }, 1800);
    };
    return NPCs;
})();
var npcs = new NPCs();
/// <reference path="../node_modules/definitely-typed-jquery/jquery.d.ts" />
/// <reference path="npcs.ts" />
/// <reference path="player.ts" />
/// <reference path="sounds.ts" />
/// <reference path="stage.ts" />
var Game = (function () {
    function Game() {
        this.currentArea = 'a000';
        this.currentDirection = 'down';
        this.directions = {
            up: 'up',
            down: 'down',
            left: 'left',
            right: 'right'
        };
        this.domain = location.protocol + '//' + location.host;
        this.fps = 60;
        this.gridCellSize = 32;
        this.loading = false;
        this.loadingMessage = '<div id="loading">Loading...</div>';
        this.preloading = false;
        this.pressedKeys = {}; // @TODO: Figure out how to type something with dynamic propery names...?
        this.prevArea = 'a000';
    }
    Game.prototype.calculateZindex = function (object) {
        object.css({
            zIndex: object.position().top
        });
    };
    Game.prototype.checkCollisions = function (object, direction) {
        var objectCoord = this.getCoordinates(object);
        var offsetLeft = 0;
        var offsetTop = 0;
        switch (direction) {
            // Up
            case this.directions.up:
                offsetTop = -1;
                break;
            // Down
            case this.directions.down:
                offsetTop = 1;
                break;
            // Left
            case this.directions.left:
                offsetLeft = -1;
                break;
            // Right
            case this.directions.right:
                offsetLeft = 1;
                break;
        }
        if (stage.collisionsMap[objectCoord.y + offsetTop]) {
            if (stage.collisionsMap[objectCoord.y + offsetTop][objectCoord.x + offsetLeft]) {
                return stage.collisionsMap[objectCoord.y + offsetTop][objectCoord.x + offsetLeft];
            }
        }
        if (stage.portalsMap[objectCoord.y + offsetTop]) {
            if (stage.portalsMap[objectCoord.y + offsetTop][objectCoord.x + offsetLeft]) {
                return stage.portalsMap[objectCoord.y + offsetTop][objectCoord.x + offsetLeft];
            }
        }
        if (stage.npcsMap[objectCoord.y + offsetTop]) {
            if (stage.npcsMap[objectCoord.y + offsetTop][objectCoord.x + offsetLeft]) {
                return stage.npcsMap[objectCoord.y + offsetTop][objectCoord.x + offsetLeft];
            }
        }
        if (stage.playersMap[objectCoord.y + offsetTop]) {
            if (stage.playersMap[objectCoord.y + offsetTop][objectCoord.x + offsetLeft]) {
                return stage.playersMap[objectCoord.y + offsetTop][objectCoord.x + offsetLeft];
            }
        }
        return false;
    };
    Game.prototype.getCoordinates = function (object) {
        var objectPos = object.position();
        return {
            x: objectPos.left / this.gridCellSize,
            y: objectPos.top / this.gridCellSize
        };
    };
    Game.prototype.moveObject = function (object, direction, callback) {
        var _this = this;
        var animateOptions = {};
        var objectPos = object.position();
        var left = objectPos.left;
        var top = objectPos.top;
        switch (direction) {
            // Up
            case this.directions.up:
                animateOptions = {
                    top: top - this.gridCellSize
                };
                break;
            // Down
            case this.directions.down:
                animateOptions = {
                    top: top + this.gridCellSize
                };
                break;
            // Left
            case this.directions.left:
                animateOptions = {
                    left: left - this.gridCellSize
                };
                break;
            // Right
            case this.directions.right:
                animateOptions = {
                    left: left + this.gridCellSize
                };
                break;
        }
        ;
        object.stop()
            .animate(animateOptions, 180, 'linear', function () {
            _this.calculateZindex(object);
            if (callback) {
                callback();
            }
        });
    };
    Game.prototype.preload = function () {
        var _this = this;
        var items = [
            // Tile Map
            '../img/tile-map.gif',
            // Player
            '../img/rene-down.gif',
            '../img/rene-down-walking.gif',
            '../img/rene-left.gif',
            '../img/rene-left-walking.gif',
            '../img/rene-up.gif',
            '../img/rene-up-walking.gif',
            // NPC
            '../img/dude.gif',
            // Modals
            '../img/modal-border.gif',
            // Emotes
            '../img/emote-happiness.gif',
            '../img/emote-love.gif',
            '../img/emote-question.gif',
            '../img/emote-sadness.gif',
            '../img/emote-talk-angry.gif',
            '../img/emote-talk-happy.gif',
            '../img/emote-think.gif',
            // Icons
            '../img/icon-continue.gif'
        ];
        var outstanding = items.length;
        var self = this;
        this.preloading = true;
        if ($('#loading').length === 0) {
            $('body').append('<div id="loading">Loading...</div>');
        }
        for (var i = 0; i < items.length; i++) {
            this.loading = true;
            $.ajax({
                type: 'GET',
                url: items[i]
            }).done(function () {
                // Do nothing
            }).fail(function () {
                // Do nothing
            }).always(function () {
                outstanding--;
                if (outstanding === 0) {
                    _this.loading = false;
                    _this.start();
                }
                ;
            });
        }
    };
    Game.prototype.start = function () {
        var _this = this;
        setInterval(function () {
            _this.update();
        }, 1000 / this.fps);
        stage.init('a000');
    };
    Game.prototype.update = function () {
        if (this.loading) {
            if ($('#loading').length === 0) {
                $('body').append(this.loadingMessage);
            }
        }
        else {
            $('#loading').remove();
        }
        if ($('.modal').length > 0) {
        }
        if (player.pc) {
            player.checkButtons();
        }
        stage.checkButtons();
    };
    return Game;
})();
var game = new Game();
/** BINDINGS **/
$(document).on('keydown', function (event) {
    event.preventDefault();
    game.pressedKeys[event.which] = true;
});
$(document).on('keyup', function (event) {
    event.preventDefault();
    game.pressedKeys[event.which] = false;
    // modal.allowPress = true;
    player.allowPress = true;
});
/** GAME START! **/
$(document).on('ready', function () {
    game.preload();
});
