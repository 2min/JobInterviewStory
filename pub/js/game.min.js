
Dialogues = {
    'd000': {
        type        : 'dialogue',
        text        : 'Hello, world!',
        emote       : 'talkHappy',
        end         : true
    },

    'd001': {
        type        : 'dialogue',
        text        : 'Do you want to go to lunch? I\'m hungry...',
        emote       : 'question',
        goTo        : 'c000'
    },

    'c000': {
        type    : 'choice',
        emote   : 'think',
        choices : [
            {
                label       : 'Yes',
                goTo        : 'd002'
            },

            {
                label       : 'No',
                goTo        : 'd003'
            }
        ]
    },

    'd002': {
        type        : 'dialogue',
        text        : 'Alright!',
        emote       : 'happiness',
        end         : true
    },

    'd003': {
        type        : 'dialogue',
        text        : 'Awwwww!',
        emote       : 'sadness',
        end         : true
    }
}

/** GAME ******************************************************************************************/

function Game () {
    this.activeNPC           = '';
    this.currentArea         = 'a000';
    this.currentDirection    = 'down';
    this.currentFocus        = '';
    this.directions          = {
        up      : 'up',
        down    : 'down',
        left    : 'left',
        right   : 'right'
    }
    this.fps                 = 60;
    this.gridCellSize        = 32;
    this.pressedKeys         = [];
    this.prevArea            = 'a000';

    /**
     *
     */
    this.calculateZindex = function (object) {
        object.css({
            zIndex: object.position().top
        });
    }

    /**
     *
     */
    this.checkCollisions = function (object, direction) {
        var objectCoord = $.game.getCoordinates(object),
            offsetL     = 0,
            offsetT     = 0;

        switch (direction) {
            case $.game.directions.up:
                offsetT = -1;

                break;

            case $.game.directions.down:
                offsetT = 1;

                break;

            case $.game.directions.left:
                offsetL = -1;

                break;

            case $.game.directions.right:
                offsetL = 1;

                break;
        }

        if ($.stage.collisionsMap[objectCoord.y + offsetT]) {
            if ($.stage.collisionsMap[objectCoord.y + offsetT][objectCoord.x + offsetL]) {
                return $.stage.collisionsMap[objectCoord.y + offsetT][objectCoord.x + offsetL];
            }
        }

        if ($.stage.portalsMap[objectCoord.y + offsetT]) {
            if ($.stage.portalsMap[objectCoord.y + offsetT][objectCoord.x + offsetL]) {
                return $.stage.portalsMap[objectCoord.y + offsetT][objectCoord.x + offsetL];
            }
        }

        if ($.stage.npcsMap[objectCoord.y + offsetT]) {
            if ($.stage.npcsMap[objectCoord.y + offsetT][objectCoord.x + offsetL]) {
                return $.stage.npcsMap[objectCoord.y + offsetT][objectCoord.x + offsetL];
            }
        }

        if ($.stage.playersMap[objectCoord.y + offsetT]) {
            if ($.stage.playersMap[objectCoord.y + offsetT][objectCoord.x + offsetL]) {
                return $.stage.playersMap[objectCoord.y + offsetT][objectCoord.x + offsetL];
            }
        }

        return false;
    }

    /**
     *
     */
    this.getCoordinates = function (object) {
        var objectPos = object.position();

        return {
            'x': objectPos.left / $.game.gridCellSize,
            'y': objectPos.top / $.game.gridCellSize
        }
    }

    /**
     *
     */
    this.moveObject = function (object, direction, callback) {
        var
            animateOptions  = {},
            objectPos       = object.position(),
            left            = objectPos.left,
            top             = objectPos.top;

        switch (direction) {
            case $.game.directions.up:
                animateOptions = {
                    top: top - $.game.gridCellSize
                }

                break;

            case $.game.directions.down:
                animateOptions = {
                    top: top + $.game.gridCellSize
                }

                break;

            case $.game.directions.left:
                animateOptions = {
                    left: left - $.game.gridCellSize
                }

                break;

            case $.game.directions.right:
                animateOptions = {
                    left: left + $.game.gridCellSize
                }

                break;

        }

        object.stop().animate(
            animateOptions,
            180,
            'linear',
            function () {
                $.game.calculateZindex(object);

                if (callback) {
                    callback();
                }
            }
        );
    }

    /**
     *
     */
    this.start = function () {
        setInterval(function () {
            $.game.update();
        }, 1000 / $.game.fps);

        $.stage.init('a000');
    }

    /**
     *
     */
    this.update = function () {
        if ($('.modal').length > 0) {
            $.modals.checkButtons();
        }

        if ($('#player').length > 0) {
            $.player.checkButtons();
        }

        $.stage.checkButtons();
    }
};

$.fn.game = function (option) {
    var
        element     = $(this[0]),
        otherArgs   = Array.prototype.slice.call(arguments, 1);

    if (typeof option !== 'undefined' && otherArgs.length > 0) {
        return element.data('game')[option].apply(this[0], [].concat(otherArgs));
    } else if (typeof option !== 'undefined') {
        return element.data('game')[option].call (this[0]);
    } else {
        return element.data('game');
    }
}

$.game = new Game();

/** BINDINGS **************************************************************************************/

//
$(document).on('keydown', function (event) {
    var key = event.keyCode || event.which;

    $.game.pressedKeys[event.keyCode] = true;
});

//
$(document).on('keyup', function (event) {
    var key = event.keyCode || event.which;

    $.game.pressedKeys[event.keyCode]   = false;
    $.modals.allowPress                 = true;
    $.player.allowPress                 = true;
});

/** GAME START! ***********************************************************************************/

//
$(document).on('ready', function () {
    $.game.start();
});


/** MODAL WINDOWS **/

function Modals () {
    this.activeModal    = '';
    this.allowPress     = true;
    this.cancelTyping   = false;
    this.continueIcon   = '<div class="icon continue"></div>'
    this.id             = 0;
    this.npc            = '';
    this.typing         = false;

    /**
     *
     */
    this.checkButtons = function () {
        var modal = $.modals.activeModal;

        if (modal.length == 0 || modal.html() == '') {
            return;
        }

        var
            activeElement   = $(document.activeElement),
            dialogue        = modal.data('modal')['dialogue'];

        if (!$.modals.allowPress) {
            return;
        }

        // Shift

        if ($.game.pressedKeys[16]) {

        }

        // Spacebar, Enter

        if ($.game.pressedKeys[13] || $.game.pressedKeys[32]) {
            $.modals.allowPress = false;

            switch (true) {
                case (activeElement.is('li')) :
                    var choice = Dialogues[dialogue].choices[activeElement.index()];

                    if (choice.action) {
                        choice.action();
                    }

                    if (choice.goTo) {
                        return modal.modal('populate', choice.goTo, Dialogues[choice.goTo]);
                    }

                    break;

                default :
                    if ($.modals.typing) {
                        $.modals.cancelTyping = true;

                        return;
                    }

                    if (Dialogues[dialogue].goTo) {
                        modal.modal('populate', Dialogues[dialogue].goTo, Dialogues[Dialogues[dialogue].goTo]);

                        break;
                    } else if (Dialogues[dialogue].end) {
                        modal.modal('destroy', $('#player'));

                        if (modal.data('modal')['npc']) {
                            modal.data('modal')['npc'].data('npc')['wanderPause'] = false;
                        }

                        break;
                    }

                    break;
            }
        }

        switch (true) {

            // W, Up Arrow

            case (($.game.pressedKeys[87] || $.game.pressedKeys[38])) :
                $.modals.allowPress = false;

                switch (true) {
                    case (activeElement.is('li')) :
                        activeElement.prev('li').trigger('focus');

                        break;
                }

                break;

            // S, Down Arrow

            case (($.game.pressedKeys[83] || $.game.pressedKeys[40])) :
                $.modals.allowPress = false;

                switch (true) {
                    case (activeElement.is('li')) :
                        activeElement.next('li').trigger('focus');

                        break;
                }

                break;

            // A, Left Arrow

            case (($.game.pressedKeys[65] || $.game.pressedKeys[37])) :
                $.modals.allowPress = false;

                break;

            // D, Right Arrow

            case (($.game.pressedKeys[68] || $.game.pressedKeys[39])) :
                $.modals.allowPress = false;

                break;

            default:

                break;
        }
    }

    /**
     *
     */
    this.create = function (size, position, dialogue, npc) {
        var
            modalCounter    = $('.modal').length,
            modal           = '',
            id              = modalCounter + '';

        $.modals.allowPress = false;

        while (id.length < (3 - ((modalCounter + '')).length + 1)) {
            id = '0' + id;
        }

        id = 'm' + id;

        $('#modals').append('<div id="' + id + '" class="modal" tabindex="0"></div>');

        modal = $('#' + id);

        modal.data('modal', new Modals());
        modal.data('modal')['id']   = id;
        modal.data('modal')['npc']  = npc ? npc : '';

        modal.css({
            left    : position.left + 'px',
            top     : position.top + 'px'
        });

        modal.animate({
            height  : size.height + 'px',
            width   : size.width + 'px'
        }, 180, function () {
            modal.modal('populate', dialogue);

            $.modals.activeModal = modal;
        });
    },

    /**
     *
     */
    this.destroy = function (focus) {
        var
            modal   = $(this),
            npc     = modal.data('modal')['npc'];

        modal.html('');

        modal.animate({
            height  : 0,
            width   : 0,
            zIndex  : 0
        }, 180, function () {
            modal.remove();

            if (npc) {
                npc.npc('destroyEmote');

                $.npc.talking = false;
            }

            if (focus) {
                focus.trigger('focus');
            }
        });
    },

    /**
     *
     */
    this.option = function (option, value) {
        var
            element = $(this),
            data    = element.data('modal');

        if (typeof value === 'undefined') {
            return data[option];
        } else {
            data[option] = value;

            switch (option) {

            }
        }
    },

    /**
     *
     */
    this.populate = function (dialogue) {
        var
            emote   = Dialogues[dialogue].emote,
            modal   = $(this),
            npc     = $.game.activeNPC,
            type    = Dialogues[dialogue].type;

        if (npc && emote) {
            npc.npc('emote', emote);
        }

        modal.data('modal')['dialogue'] = dialogue;

        switch (type) {
            case 'choice':
                var choices = '<ul class="choice">';

                $.each(Dialogues[dialogue].choices, function (index, value) {
                    choices += '<li tabindex="0">' + value.label + '</li>'
                });

                choices += '</ul>';

                modal.html(choices).find('li:first').trigger('focus');

                break;

            case 'dialogue':
                var
                    counter     = 0,
                    interval    = setInterval(function () {
                        if ($.modals.cancelTyping) {
                            modal.append(Dialogues[dialogue].text.substr(counter, Dialogues[dialogue].text.length));

                            $.modals.cancelTyping   = false;
                            $.modals.typing         = false;

                            modal.append($.modals.continueIcon);

                            clearInterval(interval);

                            return;
                        };

                        modal.append(Dialogues[dialogue].text.charAt(counter));

                        $.sounds.fx.bip.play();

                        counter++;

                        if (counter >= Dialogues[dialogue].text.length) {
                            $.modals.typing = false;

                            modal.append($.modals.continueIcon);

                            clearInterval(interval);

                            return;
                        }
                    }, 50);

                $.modals.typing = true;

                modal.html('');

                modal.trigger('focus');

                if (Dialogues[dialogue].action) {
                    Dialogues[dialogue].action();
                }

                break;
        }
    }
}

$.fn.modal = function (option) {
    var
        element     = $(this[0]),
        otherArgs   = Array.prototype.slice.call(arguments, 1);

    if (typeof option !== 'undefined' && otherArgs.length > 0) {
        return element.data('modal')[option].apply(this[0], [].concat(otherArgs));
    }

    return element.data('modal');
}

$.modals = new Modals();


/** NPCS **/

function NPC () {
    this.dialogue       = 'd000';
    this.id             = 0;
    this.talking        = false;
    this.wanderInterval = '';
    this.wanderPause    = false;

    /**
     *
     */
    this.create = function (data) {
        var npc;

        $('#objects').append('<div id="' + data.name + '" class="npc"><div class="npc-sprite"></div></div>');

        npc = $('#' + data.name);

        npc.data('npc', new NPC());
        npc.data('npc')['id']       = data.name;
        npc.data('npc')['dialogue'] = data.properties.dialogue;

        npc.css({
            left    : data.x + 'px',
            top     : (data.y - $.game.gridCellSize) + 'px'
        });

        if (!$.stage.npcsMap[(data.y / $.game.gridCellSize) - 1]) {
            $.stage.npcsMap[(data.y / $.game.gridCellSize) - 1] = {};
        }

        $.stage.npcsMap[(data.y / $.game.gridCellSize) - 1][(data.x / $.game.gridCellSize)] = npc;

        if (data.properties.wander) {
            npc.npc('wander');
        }
    },

    /**
     *
     */
    this.destroy = function () {
        var npc = $(this);

        clearInterval(npc.data('npc')['wanderInterval']);

        npc.remove();
    }

    /**
     *
     */
    this.destroyEmote = function () {
        var npc = $(this);

        npc.find('.emote').animate({
            opacity : 0,
            top     : '-48px'
        }, 100, function () {
            $(this).remove();
        });
    }

    /**
     *
     */
    this.emote = function (emotion) {
        var npc     = $(this),
            emote   = npc.find('.emote');

        if (emote.length === 0) {
            npc.append('<div class="emote ' + emotion + '" style="opacity: 0; top: -48px"></div>');

            npc.find('.emote').animate({
                opacity : 1,
                top     : '-32px'
            }, 100);
        } else {
            npc.find('.emote').replaceWith('<div class="emote ' + emotion + '"></div>');
        }
    },

    /**
     *
     */
    this.move = function (direction) {
        var npc = $(this);

        $.game.moveObject(npc, direction);
    },

    /**
     *
     */
    this.talk = function (dialogue) {
        var npc = $(this);

        if ($.npc.talking) {
            return;
        }

        $.npc.talking                    = true;
        npc.data('npc')['wanderPause']  = true;

        $.game.activeNPC = npc;

        $.modals.create(
            {
                height  : 80,
                width   : 720
            },
            {
                left    : ($(window).width() - (720 + $.game.gridCellSize)) / 2,
                top     : 20
            },
            dialogue,
            npc
        );
    },

    /**
     *
     */
    this.wander = function () {
        var npc = $(this);

        clearInterval(npc.data('npc')['wanderInterval']);

        npc.data('npc')['wanderInterval'] = setInterval(function () {
            var direction   = $.game.directions[Object.keys($.game.directions)[Math.floor(Math.random() * Object.keys($.game.directions).length)]],
                npcPos      = $.game.getCoordinates(npc);

            if (Math.random() < 0.5 || npc.data('npc')['wanderPause'] === true) {
                return;
            }

            var collision = $.game.checkCollisions(npc, direction);

            if (collision == false && !npc.is(':animated')) {
                $.game.moveObject(npc, direction, function () {
                    var newPos = $.game.getCoordinates(npc);

                    if (!$.stage.npcsMap[newPos.y]) {
                        $.stage.npcsMap[newPos.y] = {};
                    }

                    $.stage.npcsMap[newPos.y][newPos.x] = npc;

                    delete $.stage.npcsMap[npcPos.y][npcPos.x];
                });
            }
        }, 1800);
    }
}

$.fn.npc = function (option) {
    var
        element     = $(this[0]),
        otherArgs   = Array.prototype.slice.call(arguments, 1);

    if (typeof option !== 'undefined' && otherArgs.length > 0) {
        return element.data('npc')[option].apply(this[0], [].concat(otherArgs));
    } else if (typeof option !== 'undefined') {
        return element.data('npc')[option].call (this[0]);
    } else {
        return element.data('npc');
    }
}

$.npc = new NPC();


/** PLAYER **/

function Player () {
    this.allowMove          = true;
    this.allowPress         = true;
    this.direction          = null;
    this.speedMultiplier    = 1;

    /**
     *
     */
    this.checkButtons = function () {
        var player = $('#player');

        if (player.length == 0) {
            return;
        }

        var
            allowMove       = player.data('player')['allowMove'],
            allowPress      = $.player.allowPress;
            playerSprite    = $('#player-sprite');

        if (!allowPress) {
            return;
        }

        player.data('player')['speedMultiplier'] = 1;

        // Shift

        if ($.game.pressedKeys[16]) {
            player.data('player')['speedMultiplier'] = 2;
        }

        // Spacebar, Enter

        if ($.game.pressedKeys[13] || $.game.pressedKeys[32]) {
            var collision = $.game.checkCollisions(player, player.data('player')['direction']);

            $.player.allowPress = false;

            if (collision) {
                switch (true) {
                    case (collision) :
                        // Do nothing

                        break;

                    case (collision.is('.npc')) :
                        collision.npc('talk', collision.data('npc')['dialogue']);

                        break;
                }
            }
        }

        switch (true) {

            // W, Up Arrow

            case (($.game.pressedKeys[87] || $.game.pressedKeys[38])) :
                var direction = player.data('player')['direction'] = $.game.directions.up;

                player.player('move', direction);

                break;

            // S, Down Arrow

            case (($.game.pressedKeys[83] || $.game.pressedKeys[40])) :
                var direction = player.data('player')['direction'] = $.game.directions.down;

                player.player('move', direction);

                break;

            // A, Left Arrow

            case (($.game.pressedKeys[65] || $.game.pressedKeys[37])) :
                var direction = player.data('player')['direction'] = $.game.directions.left;

                player.player('move', direction);

                break;

            // D, Right Arrow

            case (($.game.pressedKeys[68] || $.game.pressedKeys[39])) :
                var direction = player.data('player')['direction'] = $.game.directions.right;

                player.player('move', direction);

                break;

            default:
                playerSprite.removeClass('walking');

                break;
        }
    }

    /**
     *
     */
    this.create = function (data) {
        var player;

        if (data.properties.prevArea === $.game.prevArea) {
            $('#objects').append('<div id="player" style="left: ' + data.x + 'px; top: ' + (data.y - 32) + 'px;"><div id="player-sprite" class="' + $.game.currentDirection + '"></div></div>');

            player = $('#player');

            player.data('player', new Player());

            if (!$.stage.playersMap[(data.y / $.game.gridCellSize) - 1]) {
                $.stage.playersMap[(data.y / $.game.gridCellSize) - 1] = {};
            }

            $.stage.playersMap[(data.y / $.game.gridCellSize) - 1][(data.x / $.game.gridCellSize)] = player;
        }
    }

    /**
     *
     */
    this.destroy = function () {
        var player = $(this);

        player.remove();
    }

    /**
     *
     */
    this.move = function (direction, callback) {
        var
            player          = $(this),
            playerPos       = $.game.getCoordinates(player);
            playerSprite    = $('#player-sprite');

        if (player.data('player')['allowMove']) {
            var collision = $.game.checkCollisions(player, direction);

            $.game.currentDirection = direction;

            playerSprite.removeClass().addClass('walking ' + direction);

            if (collision) {
                switch (true) {
                    case (collision) :
                        playerSprite.removeClass('walking');

                        $.sounds.fx.bump.play();

                        break;

                    case (collision.is('.doorway')) :
                        player.data('player')['allowMove'] = false;

                        $.sounds.fx.door.play();

                        $.game.moveObject(player, direction, function () {
                            var newPos = $.game.getCoordinates(player);

                            if (!$.stage.playersMap[newPos.y]) {
                                $.stage.playersMap[newPos.y] = {};
                            }

                            $.stage.playersMap[newPos.y][newPos.x] = player;

                            $.sounds.fx.enter.play();

                            delete $.stage.playersMap[playerPos.y][playerPos.x];

                            $.stage.init(collision.attr('data-area'));
                        });

                        break;

                    case (collision.is('.stairs')) :
                        player.data('player')['allowMove'] = false;

                        $.sounds.fx.enter.play();

                        player.player('useStairs', collision.attr('data-direction'), function () {
                            $.stage.init(collision.attr('data-area'));
                        });

                        break;
                }
            } else {
                player.data('player')['allowMove'] = false;

                $.game.moveObject(player, direction, function () {
                    var newPos = $.game.getCoordinates(player);

                    player.data('player')['allowMove'] = true;

                    if (!$.stage.playersMap[newPos.y]) {
                        $.stage.playersMap[newPos.y] = {};
                    }

                    $.stage.playersMap[newPos.y][newPos.x] = player;

                    delete $.stage.playersMap[playerPos.y][playerPos.x];
                });

                $.stage.scrollStage(direction);
            }
        }
    }

    /**
     *
     */
    this.useStairs = function (direction, callback) {
        var player      = $(this),
            playerPos   = player.position(),
            offsetL     = 0,
            offsetT     = 0;

        switch (direction) {
            case 'dl':
                offsetL = -32;
                offsetT = 0;

                break;

            case 'dr':
                offsetL = 32;
                offsetT = 32;

                break;

            case 'ul':
                offsetL = -32;
                offsetT = -32;

                break;

            case 'ur':
                offsetL = 32;
                offsetT = -32;

                break;
        }

        player.addClass('walking').stop().animate({
            left    : playerPos.left + offsetL,
            top     : playerPos.top + offsetT
        }, 180, 'linear', function () {
            if (callback) {
                callback();
            }
        });
    }
}

$.fn.player = function (option) {
    var
        element     = $(this[0]),
        otherArgs   = Array.prototype.slice.call(arguments, 1);

    if (typeof option !== 'undefined' && otherArgs.length > 0) {
        return element.data('player')[option].apply(this[0], [].concat(otherArgs));
    } else if (typeof option !== 'undefined') {
        return element.data('player')[option].call (this[0]);
    } else {
        return element.data('player');
    }
}

$.player = new Player();


/** SOUNDS ****************************************************************************************/

function Sounds () {
    this.fx = {
        bip         : new Audio('../sounds/bip.wav'),
        bump        : new Audio('../sounds/bump.wav'),
        door        : new Audio('../sounds/door.wav'),
        enter       : new Audio('../sounds/enter.wav'),
        error       : new Audio('../sounds/error.wav')
    }

    this.music = {
        fieldTheme  : new Audio('../sounds/field-theme.mp3'),
        townTheme   : new Audio('../sounds/town-theme.mp3')
    }

    this.currentMusic = '';

    this.changeMusic = function (newMusic) {
        if ($.sounds.currentMusic) {
            $.sounds.fade($.sounds.currentMusic, 0, function () {
                $.sounds.currentMusic.pause();
            });
        }

        $.sounds.currentMusic = newMusic;

        $.sounds.currentMusic.currentTime = 0;
        $.sounds.currentMusic.loop = true;
        $.sounds.currentMusic.play();

        $.sounds.fade($.sounds.currentMusic, 1);
    }

    this.fade = function (sound, volume, callback) {
        var offset  = 0.0001,
            steps   = Math.abs(sound.volume - volume) / 0.0001;

        if (sound.volume > volume) {
            offset = -0.0001;
        }

        for (var i = 1; i <= steps; i++) {
            sound.volume += offset;
        }

        if (callback) {
            callback();
        }
    }
}

$.fn.sounds = function (option) {
    var
        element     = $(this[0]),
        otherArgs   = Array.prototype.slice.call(arguments, 1);

    if (typeof option !== 'undefined' && otherArgs.length > 0) {
        return element.data('sounds')[option].apply(this[0], [].concat(otherArgs));
    } else if (typeof option !== 'undefined') {
        return element.data('sounds')[option].call (this[0]);
    } else {
        return element.data('sounds');
    }
}

$.sounds = new Sounds();


/** STAGE **/

function Stage () {
    this.collisionsMap  = [];
    this.height         = 0;
    this.npcsMap        = [];
    this.playersMap     = [];
    this.portalsMap     = [];
    this.tileMap        = {
        height  : 50,
        width   : 50
    }
    this.width          = 0;

    /**
     *
     */
    this.center = function () {
        var left        = 0,
            player      = $('#player'),
            playerPos   = player.position(),
            stage       = $('#stage'),
            top         = 0,
            windowH     = $(window).height(),
            windowW     = $(window).width();

        left    = (windowW / 2) - (playerPos.left + (player.width() / 2));
        top     = (windowH / 2) - (playerPos.top + ((player.height() + 8)/ 2));

        if ($.stage.width <= windowW && $.stage.height <= windowH) {
            left    = (windowW - $.stage.width) / 2;
            top     = (windowH - $.stage.height) / 2;
        }

        if ($.stage.width > windowW && stage.offset().left > 0 && playerPos.left < windowW
            && $.stage.height > windowH && stage.offset().top > 0 && playerPos.top < windowH) {
            left    = 0;
            top     = 0;
        }

        stage.css({
            height  : $.stage.height,
            left    : left + 'px',
            top     : top + 'px',
            width   : $.stage.width
        });
    }

    /**
     *
     */
    this.checkButtons = function () {
        // Shift

        if ($.game.pressedKeys[16]) {

        }

        // Spacebar, Enter

        if ($.game.pressedKeys[13] || $.game.pressedKeys[32]) {

        }

        switch (true) {

            // W, Up Arrow

            case (($.game.pressedKeys[87] || $.game.pressedKeys[38])) :

                break;

            // S, Down Arrow

            case (($.game.pressedKeys[83] || $.game.pressedKeys[40])) :

                break;

            // A, Left Arrow

            case (($.game.pressedKeys[65] || $.game.pressedKeys[37])) :

                break;

            // D, Right Arrow

            case (($.game.pressedKeys[68] || $.game.pressedKeys[39])) :

                break;

            default:

                break;
        }
    }

    /**
     *
     */
    this.cleanup = function () {
        $.stage.collisionsMap   = [];
        $.stage.npcsMap         = [];
        $.stage.playersMap      = [];
        $.stage.portalsMap      = [];

        // $.sounds.fade($.sounds.currentMusic, 0);

        $('.npc').each(function (index, element) {
            $(element).npc('destroy');
        });

        $('#player').each(function (index, element) {
            $(element).player('destroy');
        });

        $('#collisions').html('');
        $('#modals').html('');
        $('#objects').html('');
        $('#tiles').html('');

        $(document).trigger('keyup');
    }

    /**
     *
     */
    this.drawCollisions = function (collisions) {
        var counter = 0,
            height  = collisions.height,
            row     = 0,
            width   = collisions.width;

        $.each(collisions.data, function (index, value) {
            if (!$.stage.collisionsMap[row]) {
                $.stage.collisionsMap[row] = {};
            }

            $.stage.collisionsMap[row][counter] = value === 2;

            if (value !== 0) { // 0 is empty, 2 is a collision
                $('#collisions').append('<div class="collision" style="left: ' + counter * $.game.gridCellSize + 'px; top: ' + row * $.game.gridCellSize + 'px"></div>');
            }

            counter += (index + 1) % width === 0 ? -counter : 1;
            row += (index + 1) % width === 0 ? 1 : 0;
        });
    }

    /**
     *
     */
    this.drawObjects = function (objects) {
        $.each(objects.objects, function (index, value) {
            switch (value.type) {
                case 'player':
                    $.player.create(value);

                    break;

                case 'npc':
                    $.npc.create(value);

                    break;

                case 'doorway':
                    $('#objects').append('<div id="' + value.name + '" class="object doorway" data-area="' + value.properties.area + '" style="left: ' + value.x + 'px; top: ' + (value.y - $.game.gridCellSize) + 'px"></div>');

                    if (!$.stage.portalsMap[(value.y / $.game.gridCellSize) - 1]) {
                        $.stage.portalsMap[(value.y / $.game.gridCellSize) - 1] = {};
                    }

                    $.stage.portalsMap[(value.y / $.game.gridCellSize) - 1][(value.x / $.game.gridCellSize)] = $('#' + value.name);

                    break;

                case 'stairs':
                    $('#objects').append('<div id="' + value.name + '" class="object stairs" data-area="' + value.properties.area + '" data-direction="' + value.properties.direction + '" style="left: ' + value.x + 'px; top: ' + (value.y - $.game.gridCellSize) + 'px"></div>');

                    if (!$.stage.portalsMap[(value.y / $.game.gridCellSize) - 1]) {
                        $.stage.portalsMap[(value.y / $.game.gridCellSize) - 1] = {};
                    }

                    $.stage.portalsMap[(value.y / $.game.gridCellSize) - 1][(value.x / $.game.gridCellSize)] = $('#' + value.name);

                    break;
            }
        });
    }

    /**
     *
     */
    this.drawTiles = function (tiles) {
        var counter = 0,
            height  = tiles.height,
            row     = 0,
            width   = tiles.width;

        $.each(tiles.data, function (index, value) {
            var y   = Math.ceil(value / $.stage.tileMap.width),
                x   = (value - ((y - 1) * $.stage.tileMap.width));

            if (value !== 0) { // 0 is empty, therefore don't draw it
                $('#tiles').append('<div class="tile t' + value + ' ' + tiles.name + '" style="background-position: -' + ((x * $.game.gridCellSize) - $.game.gridCellSize) + 'px -' + ((y * $.game.gridCellSize) - $.game.gridCellSize) + 'px; left: ' + (counter * $.game.gridCellSize) + 'px; top: ' + (row * $.game.gridCellSize) + 'px"></div>');
            }

            counter += (index + 1) % width === 0 ? -counter : 1;
            row += (index + 1) % width === 0 ? 1 : 0;
        });
    }

    /**
     *
     */
    this.init = function (stage) {
        var transition = $('#transition');

        transition.animate({
            opacity: 1
        }, 180, function () {
            $.stage.cleanup();

            $.ajax({
                cache       : false,
                dataType    : 'json',
                type        : 'GET',
                url         : '../json/'+ stage +'.json',
            }).done(function (data, textStatus, jqXHR) {
                $.game.prevArea     = $.game.currentArea;
                $.game.currentArea  = stage;
                $.stage.height      = data.height * $.game.gridCellSize;
                $.stage.width       = data.width * $.game.gridCellSize;

                $.each(data.layers, function (index, value) {
                    var layer = value;

                    switch (true) {

                        // Collisions
                        case (layer.name == 'collisions') :
                            $.stage.drawCollisions(layer);

                            break;

                        // Objects
                        case (layer.type == 'objectgroup') :
                            $.stage.drawObjects(layer);

                            break;

                        // Tile Layer
                        default :
                            $.stage.drawTiles(layer);

                            break;
                    }
                });

                for (i = 0; i < $('#player, .npc, .object, .tiles3').length; i++) {
                    $.game.calculateZindex($('#player, .npc, .object, .tiles3').eq(i));
                }

                $.stage.center();

                if (data.properties.music && $.sounds.currentMusic != $.sounds.music[data.properties.music]) {
                    // $.sounds.changeMusic($.sounds.music[data.properties.music], 0);
                }

                transition.animate({
                    opacity: 0
                }, 180);
            }).fail(function (jqXHR, textStatus, errorThrown) {

            }).always(function (data, textStatus, jqXHR) {

            });
        });
    }

    this.scrollStage = function (direction) {
        var player      = $('#player'),
            playerOff   = player.offset(),
            offset      = 0,
            scrollArea  = $('#scroll-area'),
            stage       = $('#stage'),
            stagePos    = stage.position(),
            stageL      = stagePos.left,
            stageT      = stagePos.top,
            windowH     = $(window).height(),
            windowW     = $(window).width();

        if (($.stage.width > windowW || $.stage.height > windowH)) {
            switch (direction) {
                case $.game.directions.up:
                    if ((playerOff.top + ($.game.gridCellSize / 2)) < (windowH / 2) && stageT < 0) {
                        stage.stop().animate({
                            top: stageT + $.game.gridCellSize + offset
                        }, 180, 'linear');
                    }

                    break;

                case $.game.directions.down:
                    if ((playerOff.top + ($.game.gridCellSize / 2)) > (windowH / 2)
                        && Math.abs(stageT - windowH) < $.stage.height) {
                        stage.stop().animate({
                            top: stageT - $.game.gridCellSize + offset
                        }, 180, 'linear');
                    }

                    break;

                case $.game.directions.left:
                    if ((playerOff.left + ($.game.gridCellSize / 2)) < (windowW / 2) && stageL < 0) {
                        stage.stop().animate({
                            left: stageL + $.game.gridCellSize + offset
                        }, 180, 'linear');
                    }

                    break;

                case $.game.directions.right:
                    if ((playerOff.left + ($.game.gridCellSize / 2)) > (windowW / 2)
                        && Math.abs(stageL - windowW) < $.stage.width) {
                        stage.stop().animate({
                            left: stageL - $.game.gridCellSize + offset
                        }, 180, 'linear');
                    }

                    break;
            }
        }
    }
}

$.fn.stage = function (option) {
    var
        element     = $(this[0]),
        otherArgs   = Array.prototype.slice.call(arguments, 1);

    if (typeof option !== 'undefined' && otherArgs.length > 0) {
        return element.data('stage')[option].apply(this[0], [].concat(otherArgs));
    } else if (typeof option !== 'undefined') {
        return element.data('stage')[option].call (this[0]);
    } else {
        return element.data('stage');
    }
}

$.stage = new Stage();
