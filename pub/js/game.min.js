var dialogue = {
    'd200': {
        text: 'Hello, world!',
        emote: 'talkHappy'
    },
    'd201': {
        text: 'Do you want to go to lunch? I\'m hungry...',
        emote: 'question',
        goTo: 'c000'
    },
    'c000': {
        emote: 'think',
        choices: [
            {
                label: 'Yes',
                goTo: 'd202'
            },
            {
                label: 'No',
                goTo: 'd203'
            }
        ]
    },
    'd202': {
        text: 'Alright!',
        emote: 'happiness'
    },
    'd203': {
        text: 'Awwwww!',
        emote: 'sadness'
    }
};
var flavor = {
    // A000
    'f000': {
        text: 'My B.A. in Graphic Design, from <a href="http://www.atlanticu.edu" target="_blank">Atlantic University College</a>.<br />I mostly write JavaScript, these days...'
    },
    'f001': {
        text: 'The browser window\'s displaying <a href="https://github.com/robobeau" target="_blank">my GitHub profile</a>.'
    },
    'f002': {
        text: 'An Acer Predator G series PC.<br />Lately, I\'ve been using it to play Undertale...'
    },
    'f003': {
        text: 'My collection of comic—I mean, programming—books.'
    },
    'f004': {
        text: 'A picturesque landscape.'
    },
    'f005': {
        text: 'I could finish unpacking... or I could go play video games...<br />Decisions, decisions...'
    },
    'f006': {
        text: '"Clean Code"... "Eloquent JavaScript"...<br />I really should finish reading these books.'
    },
    'f007': {
        text: '"Japanese for Busy People".<br />Memorizing all the hiragana and katakana is a pain...'
    },
    'f008': {
        text: 'No time for love, Dr. Jones!'
    },
    // A001
    'f100': {
        text: '"Final Fantasy VI"... "Chrono Trigger"... "Secret Of Mana"...<br />The classics are all here!'
    },
    'f101': {
        text: 'A bald man in a white cape and yellow jumpsuit is running around defeating bad guys with one punch.'
    },
    'f102': {
        text: 'Various anime figures, all meticulously posed. I swear, I\'m an adult.'
    },
    'f103': {
        text: 'There\'s nothing in the trash bin.'
    },
    'f104': {
        text: 'The fridge is stocked with endless bottles of Dr. Pepper.<br />No, YOU have a problem!'
    },
    'f105': {
        text: 'The sun is a wondrous body, like a magnificent father!<br />If only I could be so grossly incandescent!'
    },
    'f106': {
        text: 'One missed call from (407) 517-8634. Probably a telemarketer.'
    },
    // A002
    'f200': {
        text: 'My Amazon package has yet to arrive...'
    },
    'f201': {
        text: 'This isn\'t my mailbox...'
    }
};
/// <reference path="../typings/jquery/jquery.d.ts" />
/// <reference path="dialogue.ts" />
/// <reference path="game.ts" />
/// <reference path="sounds.ts" />
/// <reference path="stage.ts" />
var NPCs = (function () {
    function NPCs() {
    }
    NPCs.prototype.create = function (data) {
        var npc = $('<div id="' + data.name + '" class="npc">' +
            '<div class="npc-sprite"></div>' +
            '</div>');
        npc.data('npc', new NPC(npc));
        stage.objectsDiv.append(npc);
        npc.data('npc').dialogueId = data.properties.dialogue;
        npc.data('npc').id = data.name;
        npc.data('npc').npc = npc;
        npc.css({
            left: data.x + 'px',
            top: (data.y - game.gridCellSize) + 'px'
        });
        if (!stage.npcsMap[(data.y / game.gridCellSize) - 1]) {
            stage.npcsMap[(data.y / game.gridCellSize) - 1] = {};
        }
        stage.npcsMap[(data.y / game.gridCellSize) - 1][(data.x / game.gridCellSize)] = npc;
        if (data.properties.wander) {
            npc.data('npc').wander();
        }
    };
    return NPCs;
})();
var NPC = (function () {
    function NPC(npc) {
        this.dialogueId = 'd000';
        this.id = 0;
        this.talking = false;
        this.wanderPause = false;
        this.self = npc;
    }
    NPC.prototype.destroy = function () {
        clearInterval(this.wanderInterval);
        this.self.remove();
    };
    NPC.prototype.destroyEmote = function () {
        var _this = this;
        this.self.find('.emote')
            .animate({
            opacity: 0,
            top: '-48px'
        }, 100, 'linear', function () {
            $(_this).remove();
        });
    };
    NPC.prototype.emote = function (emotion) {
        var emote = this.self.find('.emote');
        if (emote.length === 0) {
            emote = $('<div class="emote ' + emotion + '" style="opacity: 0; top: -48px"></div>');
            this.self.append(emote);
            emote.animate({
                opacity: 1,
                top: '-32px'
            }, 100, 'linear');
        }
        else {
            emote.replaceWith('<div class="emote ' + emotion + '"></div>');
        }
    };
    NPC.prototype.move = function (direction) {
        var _this = this;
        var collision = game.checkCollisions(this.self, direction);
        var npcPos = game.getCoordinates(this.self);
        var npcSprite = this.self.find('.npc-sprite');
        game.currentDirection = direction;
        npcSprite.removeClass('walking up down left right')
            .addClass('walking ' + direction);
        if (collision) {
            npcSprite.removeClass('walking');
        }
        else {
            game.moveObject(this.self, direction, function () {
                var newPos = game.getCoordinates(_this.self);
                if (!stage.npcsMap[newPos.y]) {
                    stage.npcsMap[newPos.y] = {};
                }
                stage.npcsMap[newPos.y][newPos.x] = _this.self;
                delete stage.npcsMap[npcPos.y][npcPos.x];
                npcSprite.removeClass('walking');
            });
        }
    };
    NPC.prototype.talk = function () {
        if (this.talking) {
            return;
        }
        this.talking = true;
        this.wanderPause = true;
        game.activeNPC = this.self;
        modals.create({
            dialogue: dialogue[this.dialogueId],
            npc: this.self,
            position: {
                left: ($(window).width() - (720 + game.gridCellSize)) / 2,
                top: 20
            },
            size: {
                height: 80,
                width: 720
            },
            type: 'dialogue'
        });
    };
    NPC.prototype.wander = function () {
        var _this = this;
        clearInterval(this.wanderInterval);
        this.wanderInterval = setInterval(function () {
            if (Math.random() < 0.5 || _this.wanderPause === true) {
                return;
            }
            _this.move(game.directions[Object.keys(game.directions)[Math.floor(Math.random() * Object.keys(game.directions).length)]]);
        }, Math.floor(Math.random() * (1800 - 600) + 600)); // @TODO: Tweak this more
    };
    return NPC;
})();
var npcs = new NPCs();
/// <reference path="../typings/jquery/jquery.d.ts" />
/// <reference path="dialogue.ts" />
/// <reference path="game.ts" />
/// <reference path="sounds.ts" />
var Modals = (function () {
    function Modals() {
        this.modalCounter = 0;
    }
    Modals.prototype.create = function (options) {
        var delay = 0;
        var id = String(this.modalCounter);
        var modal;
        while (id.length < (3 - id.length + 1)) {
            id = '0' + id;
        }
        id = 'm' + id;
        modal = $('<div id="' + id + '" class="modal ' + options.type + '" tabindex="0"></div>');
        if (options.type === 'notification') {
            delay = 200;
            $('.modal.notification').not(modal).each(function (index, element) {
                $(element).data('modal').destroy(null);
            });
        }
        setTimeout(function () {
            modal.data('modal', new Modal(modal));
            modal.data('modal').id = id;
            modal.data('modal').dialogue = options.dialogue;
            modal.data('modal').type = options.type;
            if (options.npc) {
                modal.data('modal').npc = options.npc;
            }
            stage.modalsDiv.append(modal);
            if (options.position) {
                modal.css({
                    left: options.position.left,
                    top: options.position.top
                });
            }
            modal.animate({
                height: options.size.height,
                width: options.size.width
            }, 200, function () {
                if (options.type !== 'notification') {
                    game.activeModal = modal;
                }
                modal.data('modal').populate();
            });
        }, delay);
        this.modalCounter++;
    };
    return Modals;
})();
var Modal = (function () {
    function Modal(modal) {
        this.allowPress = true;
        this.cancelTyping = false;
        this.continueIcon = $('<div class="icon continue"></div>');
        this.id = 0;
        this.typing = false;
        this.self = modal;
    }
    Modal.prototype.checkButtons = function () {
        if (!this.allowPress) {
            return;
        }
        var activeElement = $(document.activeElement);
        if (game.pressedKeys[13] || game.pressedKeys[32]) {
            this.allowPress = false;
            if (activeElement.is('li')) {
                var choice = this.dialogue.choices[activeElement.index()];
                if (typeof choice.action === 'function') {
                    choice.action();
                }
                if (choice.goTo) {
                    this.dialogue = dialogue[choice.goTo];
                    this.type = this.dialogue.choices ? 'choice' : 'dialogue';
                    this.populate();
                }
            }
            else {
                if (this.typing) {
                    this.cancelTyping = true;
                }
                else if (this.dialogue.goTo) {
                    this.dialogue = dialogue[this.dialogue.goTo];
                    this.type = this.dialogue.choices ? 'choice' : 'dialogue';
                    this.populate();
                }
                else {
                    this.destroy(game.activePlayer);
                }
            }
        }
        if ((game.pressedKeys[87] || game.pressedKeys[38])) {
            this.allowPress = false;
            if (activeElement.is('li')) {
                activeElement.prev('li').trigger('focus');
            }
        }
        else if ((game.pressedKeys[83] || game.pressedKeys[40])) {
            this.allowPress = false;
            if (activeElement.is('li')) {
                activeElement.next('li').trigger('focus');
            }
        }
    };
    Modal.prototype.destroy = function (focus) {
        var _this = this;
        this.self.html('');
        this.self.animate({
            height: 0,
            width: 0,
            zIndex: 0
        }, 200, function () {
            _this.modalInterval && clearInterval(_this.modalInterval);
            _this.modalTimeout && clearTimeout(_this.modalTimeout);
            if (_this.type !== 'notification') {
                game.activeModal = undefined;
                if (_this.npc) {
                    _this.npc.data('npc').destroyEmote();
                    _this.npc.data('npc').talking = false;
                    _this.npc.data('npc').wanderPause = false;
                }
                if (game.activePlayer) {
                    game.activePlayer.data('player').allowMove = true;
                    game.activePlayer.data('player').talking = false;
                }
            }
            if (focus) {
                focus.trigger('focus');
            }
            _this.self.remove();
        });
    };
    Modal.prototype.populate = function () {
        var _this = this;
        if (game.activeNPC && this.dialogue.emote) {
            game.activeNPC.data('npc').emote(this.dialogue.emote);
        }
        switch (this.type) {
            case 'choice':
                var choices = '<ul class="choice">';
                $.each(this.dialogue.choices, function (index, value) {
                    choices += '<li tabindex="0">' + value.label + '</li>';
                });
                choices += '</ul>';
                this.self.html(choices)
                    .find('li:first').trigger('focus');
                break;
            case 'dialogue':
            case 'flavor':
                var counter = 0;
                var interval = setInterval(function () {
                    if (_this.cancelTyping) {
                        _this.cancelTyping = false;
                        _this.typing = false;
                        _this.self.append(_this.dialogue.text.substr(counter, _this.dialogue.text.length));
                        _this.self.append(_this.continueIcon);
                        clearInterval(interval);
                        return;
                    }
                    ;
                    _this.self.append(_this.dialogue.text.charAt(counter));
                    sounds.fx.bip.play();
                    counter++;
                    if (counter >= _this.dialogue.text.length) {
                        _this.typing = false;
                        _this.self.append(_this.continueIcon);
                        clearInterval(interval);
                        return;
                    }
                }, 60);
                this.typing = true;
                this.self.html('');
                if (typeof this.dialogue.action === 'function') {
                    this.dialogue.action();
                }
                break;
            case 'notification':
                this.self.append(this.dialogue.text);
                this.modalTimeout = setTimeout(function () {
                    _this.destroy(null);
                }, 10000);
                break;
        }
    };
    return Modal;
})();
var modals = new Modals();
/// <reference path="../typings/jquery/jquery.d.ts" />
/// <reference path="game.ts" />
/// <reference path="modals.ts" />
/// <reference path="npcs.ts" />
/// <reference path="sounds.ts" />
/// <reference path="stage.ts" />
var Players = (function () {
    function Players() {
    }
    Players.prototype.create = function (data) {
        if (data.properties.prevArea === game.prevArea) {
            var player = $('<div id="player" style="left: ' + data.x + 'px; top: ' + (data.y - 32) + 'px;">' +
                '<div id="player-sprite" class="' + game.currentDirection + '"></div>' +
                '</div>');
            player.data('player', new Player(player));
            player.data('player').sprite = player.find('#player-sprite');
            stage.objectsDiv.append(player);
            game.activePlayer = player;
            if (!stage.playersMap[(data.y / game.gridCellSize) - 1]) {
                stage.playersMap[(data.y / game.gridCellSize) - 1] = {};
            }
            stage.playersMap[(data.y / game.gridCellSize) - 1][(data.x / game.gridCellSize)] = player;
        }
    };
    return Players;
})();
var Player = (function () {
    function Player(player) {
        this.allowMove = true;
        this.allowPress = true;
        this.speedMultiplier = 1;
        this.talking = false;
        this.self = player;
    }
    Player.prototype.checkButtons = function () {
        if (!this.allowPress) {
            return;
        }
        if (game.pressedKeys[16]) {
            this.speedMultiplier = 2;
        }
        else {
            this.speedMultiplier = 1;
        }
        if (game.pressedKeys[13] || game.pressedKeys[32]) {
            this.allowPress = false;
            var collision = game.checkCollisions(this.self, this.direction);
            if (collision) {
                switch (collision.type) {
                    case 'npc':
                        this.allowMove = false;
                        collision.object.data('npc').talk();
                        break;
                    case 'flavor':
                        if (this.talking) {
                            return;
                        }
                        this.allowMove = false;
                        this.talking = true;
                        modals.create({
                            dialogue: flavor[collision.object.attr('dialogue')],
                            position: {
                                left: ($(window).width() - (720 + game.gridCellSize)) / 2,
                                top: 20
                            },
                            size: {
                                height: 80,
                                width: 720
                            },
                            type: 'dialogue'
                        });
                        break;
                }
            }
        }
        if (game.pressedKeys[87] || game.pressedKeys[38]) {
            game.currentDirection = this.direction = game.directions.up;
            this.move();
        }
        else if (game.pressedKeys[83] || game.pressedKeys[40]) {
            game.currentDirection = this.direction = game.directions.down;
            this.move();
        }
        else if (game.pressedKeys[65] || game.pressedKeys[37]) {
            game.currentDirection = this.direction = game.directions.left;
            this.move();
        }
        else if (game.pressedKeys[68] || game.pressedKeys[39]) {
            game.currentDirection = this.direction = game.directions.right;
            this.move();
        }
        else {
            this.sprite.removeClass('walking');
        }
    };
    Player.prototype.destroy = function () {
        game.activePlayer = undefined;
        this.self.remove();
    };
    Player.prototype.move = function () {
        var _this = this;
        if (!this.allowMove) {
            return;
        }
        var collision = game.checkCollisions(this.self, this.direction);
        var pcMapPosition = game.getCoordinates(this.self);
        this.sprite.removeClass().addClass('walking ' + this.direction);
        if (collision) {
            switch (collision.type) {
                case 'portal':
                    this.allowMove = false;
                    if (collision.object.is('.doorway')) {
                        this.useDoor(collision.object.attr('direction'), function () {
                            stage.init(collision.object.attr('area'));
                        });
                    }
                    else if (collision.object.is('.stairs')) {
                        this.useStairs(collision.object.attr('direction'), function () {
                            stage.init(collision.object.attr('area'));
                        });
                    }
                    break;
                default:
                    this.sprite.removeClass('walking');
                    sounds.fx.bump.play();
                    break;
            }
        }
        else {
            this.allowMove = false;
            game.moveObject(this.self, this.direction, function () {
                var newPos = game.getCoordinates(_this.self);
                if (!stage.playersMap[newPos.y]) {
                    stage.playersMap[newPos.y] = {};
                }
                stage.playersMap[newPos.y][newPos.x] = _this.self;
                delete stage.playersMap[pcMapPosition.y][pcMapPosition.x];
                _this.allowMove = true;
            });
            stage.scrollStage(this.direction);
        }
    };
    Player.prototype.useDoor = function (direction, callback) {
        var _this = this;
        var pcMapPosition = game.getCoordinates(this.self);
        sounds.fx.door.play();
        game.moveObject(this.self, direction, function () {
            var newPos = game.getCoordinates(_this.self);
            if (!stage.playersMap[newPos.y]) {
                stage.playersMap[newPos.y] = {};
            }
            stage.playersMap[newPos.y][newPos.x] = _this.self;
            sounds.fx.enter.play();
            delete stage.playersMap[pcMapPosition.y][pcMapPosition.x];
            callback();
        });
    };
    Player.prototype.useStairs = function (direction, callback) {
        var pcMapPosition = game.getCoordinates(this.self);
        var pcPosition = this.self.position();
        var offsetLeft = 0;
        var offsetTop = 0;
        switch (direction) {
            case 'dl':
                offsetLeft = -32;
                offsetTop = 0; // Player clips through the stairs if set to 32
                break;
            case 'dr':
                offsetLeft = 32;
                offsetTop = 32;
                break;
            case 'ul':
                offsetLeft = -32;
                offsetTop = -32;
                break;
            case 'ur':
                offsetLeft = 32;
                offsetTop = -32;
                break;
        }
        sounds.fx.enter.play();
        this.self.addClass('walking').stop()
            .animate({
            left: pcPosition.left + offsetLeft,
            top: pcPosition.top + offsetTop
        }, 200, 'linear', function () {
            delete stage.playersMap[pcMapPosition.y][pcMapPosition.x];
            callback();
        });
    };
    return Player;
})();
var players = new Players();
/// <reference path="../typings/jquery/jquery.d.ts" />
/// <reference path="game.ts" />
/// <reference path="npcs.ts" />
/// <reference path="player.ts" />
/// <reference path="sounds.ts" />
var Stage = (function () {
    function Stage() {
        this.collisionsMap = [];
        this.flavorsMap = [];
        this.height = 0;
        this.npcsMap = [];
        this.playersMap = [];
        this.portalsMap = [];
        this.tileMap = {
            height: 50,
            width: 50
        };
        this.width = 0;
    }
    Stage.prototype.center = function () {
        var left = 0;
        var playerPos = game.activePlayer.position();
        var top = 0;
        var windowHeight = $(window).height();
        var windowWidth = $(window).width();
        left = (windowWidth / 2) - (playerPos.left + (game.activePlayer.width() / 2));
        top = (windowHeight / 2) - (playerPos.top + ((game.activePlayer.height() + 8) / 2));
        if (this.width <= windowWidth && this.height <= windowHeight) {
            left = (windowWidth - this.width) / 2;
            top = (windowHeight - this.height) / 2;
        }
        if (this.width > windowWidth && this.self.offset().left > 0 && playerPos.left < windowWidth
            && this.height > windowHeight && this.self.offset().top > 0 && playerPos.top < windowHeight) {
            left = 0;
            top = 0;
        }
        this.self.css({
            height: this.height,
            left: left + 'px',
            top: top + 'px',
            width: this.width
        });
    };
    Stage.prototype.cleanup = function () {
        var npcs = $('.npc');
        this.collisionsMap = [];
        this.flavorsMap = [];
        this.npcsMap = [];
        this.playersMap = [];
        this.portalsMap = [];
        game.activeModal && game.activeModal.data('modal').destroy();
        for (var i = 0; i < npcs.length; i++) {
            $(npcs[i]).data('npc').destroy();
        }
        game.activeNPC = undefined;
        game.activePlayer && game.activePlayer.data('player').destroy();
        this.collisionsDiv.html('');
        this.modalsDiv.html('');
        this.objectsDiv.html('');
        this.tilesDiv.html('');
        $(document).trigger('keyup');
    };
    Stage.prototype.createObject = function (object) {
        var objectTemplate = '<div id="' + object.name + '" ' +
            'class="object ' + object.type + '" ' +
            'area="' + object.properties.area + '" ';
        if (object.properties.dialogue) {
            objectTemplate += 'dialogue="' + object.properties.dialogue + '" ';
        }
        if (object.properties.direction) {
            objectTemplate += 'direction="' + object.properties.direction + '" ';
        }
        objectTemplate += 'style="left: ' + object.x + 'px; top: ' + (object.y - game.gridCellSize) + 'px"></div>';
        var objectDiv = $(objectTemplate);
        this.objectsDiv.append(objectDiv);
        switch (object.type) {
            case 'doorway':
            case 'stairs':
                if (!this.portalsMap[(object.y / game.gridCellSize) - 1]) {
                    this.portalsMap[(object.y / game.gridCellSize) - 1] = {};
                }
                this.portalsMap[(object.y / game.gridCellSize) - 1][(object.x / game.gridCellSize)] = objectDiv;
                break;
            case 'flavor':
                if (!this.flavorsMap[(object.y / game.gridCellSize) - 1]) {
                    this.flavorsMap[(object.y / game.gridCellSize) - 1] = {};
                }
                this.flavorsMap[(object.y / game.gridCellSize) - 1][(object.x / game.gridCellSize)] = objectDiv;
                break;
        }
    };
    Stage.prototype.drawCollisions = function (collisions) {
        var counter = 0;
        var row = 0;
        var width = collisions.width;
        for (var i = 0; i < collisions.data.length; i++) {
            var data = collisions.data[i];
            if (!this.collisionsMap[row]) {
                this.collisionsMap[row] = {};
            }
            this.collisionsMap[row][counter] = data === 2;
            if (data !== 0) {
                var collision = $('<div class="collision" ' +
                    'style="left: ' + (counter * game.gridCellSize) + 'px; top: ' + (row * game.gridCellSize) + 'px">' +
                    '</div>');
                this.collisionsDiv.append(collision);
            }
            counter += (i + 1) % width === 0 ? -counter : 1;
            row += (i + 1) % width === 0 ? 1 : 0;
        }
    };
    Stage.prototype.drawObjects = function (objects) {
        for (var i = 0; i < objects.objects.length; i++) {
            var object = objects.objects[i];
            switch (object.type) {
                case 'player':
                    players.create(object);
                    break;
                case 'npc':
                    npcs.create(object);
                    break;
                default:
                    this.createObject(object);
                    break;
            }
        }
    };
    Stage.prototype.drawTiles = function (tiles) {
        var counter = 0;
        var row = 0;
        var width = tiles.width;
        for (var i = 0; i < tiles.data.length; i++) {
            var tile = tiles.data[i];
            var y = Math.ceil(tile / this.tileMap.width);
            var x = (tile - ((y - 1) * this.tileMap.width));
            if (tile !== 0) {
                var tileDiv = $('<div class="tile t' + tile + ' ' + tiles.name + '" ' +
                    'style="background-position: -' + ((x * game.gridCellSize) - game.gridCellSize) + 'px -' + ((y * game.gridCellSize) - game.gridCellSize) + 'px; left: ' + (counter * game.gridCellSize) + 'px; top: ' + (row * game.gridCellSize) + 'px">' +
                    '</div>');
                this.tilesDiv.append(tileDiv);
            }
            counter += (i + 1) % width === 0 ? -counter : 1;
            row += (i + 1) % width === 0 ? 1 : 0;
        }
    };
    Stage.prototype.init = function (stageID) {
        var _this = this;
        var transition = $('#transition');
        transition.animate({
            opacity: 1
        }, 200, 'linear', function () {
            _this.cleanup();
            game.loading = true;
            $.ajax({
                // cache: false, // For development purposes
                dataType: 'json',
                type: 'GET',
                url: '../json/' + stageID + '.json'
            }).done(function (data, textStatus, jqXHR) {
                game.prevArea = game.currentArea;
                game.currentArea = stageID;
                _this.height = data.height * game.gridCellSize;
                _this.width = data.width * game.gridCellSize;
                for (var i = 0; i < data.layers.length; i++) {
                    var layer = data.layers[i];
                    switch (true) {
                        case (layer.name === 'collisions'):
                            _this.drawCollisions(layer);
                            break;
                        case (layer.type === 'objectgroup'):
                            _this.drawObjects(layer);
                            break;
                        default:
                            _this.drawTiles(layer);
                            break;
                    }
                }
                var objects = $('#player, .npc, .object, .tiles3');
                for (var j = 0; j < objects.length; j++) {
                    game.calculateZindex(objects.eq(j));
                }
                _this.center();
                game.loading = false;
                if (data.properties.music
                    && (!sounds.currentMusic || sounds.currentMusic.src != sounds.music[data.properties.music])) {
                    sounds.currentMusicId = data.properties.music;
                    sounds.changeMusic(sounds.music[data.properties.music]);
                }
                sounds.fade(sounds.currentMusic, data.properties.musicVol);
                transition.animate({
                    opacity: 0
                }, 200);
            }).fail(function (jqXHR, textStatus, errorThrown) {
                // @TODO: Handle this!
            }).always(function (data, textStatus, jqXHR) {
                // @TODO: Handle this!
            });
        });
    };
    Stage.prototype.scrollStage = function (direction) {
        var playerOff = game.activePlayer.offset();
        var offset = 0;
        var stagePos = this.self.position();
        var stageL = stagePos.left;
        var stageT = stagePos.top;
        var windowH = $(window).height();
        var windowW = $(window).width();
        if ((this.width > windowW || this.height > windowH)) {
            switch (direction) {
                case game.directions.up:
                    if ((playerOff.top + (game.gridCellSize / 2)) < (windowH / 2) && stageT < 0) {
                        this.self.stop().animate({
                            top: stageT + game.gridCellSize + offset
                        }, 200, 'linear');
                    }
                    break;
                case game.directions.down:
                    if ((playerOff.top + (game.gridCellSize / 2)) > (windowH / 2)
                        && Math.abs(stageT - windowH) < this.height) {
                        this.self.stop().animate({
                            top: stageT - game.gridCellSize + offset
                        }, 200, 'linear');
                    }
                    break;
                case game.directions.left:
                    if ((playerOff.left + (game.gridCellSize / 2)) < (windowW / 2) && stageL < 0) {
                        this.self.stop().animate({
                            left: stageL + game.gridCellSize + offset
                        }, 200, 'linear');
                    }
                    break;
                case game.directions.right:
                    if ((playerOff.left + (game.gridCellSize / 2)) > (windowW / 2)
                        && Math.abs(stageL - windowW) < this.width) {
                        this.self.stop().animate({
                            left: stageL - game.gridCellSize + offset
                        }, 200, 'linear');
                    }
                    break;
            }
        }
    };
    return Stage;
})();
var stage = new Stage();
/// <reference path="../typings/jquery/jquery.d.ts" />
/// <reference path="game.ts" />
/// <reference path="stage.ts" />
var Sounds = (function () {
    function Sounds() {
        this.domain = location.protocol + '//' + location.host;
        this.fx = {
            bip: new Audio(this.domain + '/sounds/bip.wav'),
            bump: new Audio(this.domain + '/sounds/bump.wav'),
            door: new Audio(this.domain + '/sounds/door.wav'),
            enter: new Audio(this.domain + '/sounds/enter.wav'),
            error: new Audio(this.domain + '/sounds/error.wav')
        };
        this.music = {
            shadesOfRed: this.domain + '/sounds/Pokemon_Red_Version_Shades_of_Red_OC_ReMix.mp3',
            wetDreams: this.domain + '/sounds/Pokemon_Blue_Version_Wet_Dreams_OC_ReMix.mp3'
        };
    }
    Sounds.prototype.changeMusic = function (newMusic) {
        var _this = this;
        if (this.currentMusic) {
            this.fade(this.currentMusic, 0, function () {
                _this.currentMusic.pause();
            });
        }
        game.loading = true;
        this.currentMusic = new Audio(newMusic);
        this.currentMusic.canplaythrough = this.playMusic();
    };
    Sounds.prototype.fade = function (sound, volume, callback) {
        var offset = 0.0001;
        var steps = Math.abs(sound.volume - volume) / 0.0001;
        if (sound.volume > volume) {
            offset = -0.0001;
        }
        for (var i = 1; i <= steps; i++) {
            sound.volume += offset;
        }
        if (callback) {
            callback();
        }
    };
    Sounds.prototype.playMusic = function () {
        game.loading = false;
        this.currentMusic.loop = true;
        this.currentMusic.play();
        modals.create({
            dialogue: music[this.currentMusicId],
            position: {
                left: 20 + 3,
                top: $(window).height() - 68 - 3 // The 3 is half the border-image-outset value
            },
            size: {
                height: 16,
                width: '25%'
            },
            type: 'notification'
        });
    };
    return Sounds;
})();
var sounds = new Sounds();
/// <reference path="../typings/jquery/jquery.d.ts" />
/// <reference path="sounds.ts" />
/// <reference path="stage.ts" />
var Game = (function () {
    function Game() {
        this.currentArea = 'a000';
        this.currentDirection = 'down';
        this.directions = {
            up: 'up',
            down: 'down',
            left: 'left',
            right: 'right'
        };
        this.domain = location.protocol + '//' + location.host;
        this.fps = 60;
        this.gridCellSize = 32;
        this.loading = false;
        this.loadingMessage = $('<div id="loading">Loading...</div>');
        this.preloading = false;
        this.pressedKeys = {}; // @TODO: Figure out how to type something with dynamic property names...?
        this.prevArea = 'a000';
        this.bodyDiv = $('body');
    }
    Game.prototype.calculateZindex = function (object) {
        object.css({
            zIndex: object.position().top
        });
    };
    Game.prototype.checkCollisions = function (object, direction) {
        var collisionType;
        var objectCoordinates = this.getCoordinates(object);
        var offsetLeft = 0;
        var offsetTop = 0;
        switch (direction) {
            case this.directions.up:
                offsetTop = -1;
                break;
            case this.directions.down:
                offsetTop = 1;
                break;
            case this.directions.left:
                offsetLeft = -1;
                break;
            case this.directions.right:
                offsetLeft = 1;
                break;
        }
        // Collisions
        if (stage.collisionsMap[objectCoordinates.y + offsetTop]
            && stage.collisionsMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]) {
            return {
                type: 'collision',
                object: stage.collisionsMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]
            };
        }
        // Flavor
        if (stage.flavorsMap[objectCoordinates.y + offsetTop]
            && stage.flavorsMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]) {
            return {
                type: 'flavor',
                object: stage.flavorsMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]
            };
        }
        // NPCs
        if (stage.npcsMap[objectCoordinates.y + offsetTop]
            && stage.npcsMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]) {
            return {
                type: 'npc',
                object: stage.npcsMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]
            };
        }
        // Players
        if (stage.playersMap[objectCoordinates.y + offsetTop]
            && stage.playersMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]) {
            return {
                type: 'player',
                object: stage.playersMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]
            };
        }
        // Portals
        if (stage.portalsMap[objectCoordinates.y + offsetTop]
            && stage.portalsMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]) {
            return {
                type: 'portal',
                object: stage.portalsMap[objectCoordinates.y + offsetTop][objectCoordinates.x + offsetLeft]
            };
        }
        return;
    };
    Game.prototype.getCoordinates = function (object) {
        var objectPos = object.position();
        return {
            x: objectPos.left / this.gridCellSize,
            y: objectPos.top / this.gridCellSize
        };
    };
    Game.prototype.init = function () {
        stage.collisionsDiv = $('#collisions');
        stage.modalsDiv = $('#modals');
        stage.objectsDiv = $('#objects');
        stage.tilesDiv = $('#tiles');
        stage.self = $('#stage');
        game.preload();
    };
    Game.prototype.moveObject = function (object, direction, callback) {
        var _this = this;
        var animateOptions = {};
        var objectPos = object.position();
        var left = objectPos.left;
        var top = objectPos.top;
        switch (direction) {
            case this.directions.up:
                animateOptions = {
                    top: '-=' + this.gridCellSize
                };
                break;
            case this.directions.down:
                animateOptions = {
                    top: '+=' + this.gridCellSize
                };
                break;
            case this.directions.left:
                animateOptions = {
                    left: '-=' + this.gridCellSize
                };
                break;
            case this.directions.right:
                animateOptions = {
                    left: '+=' + this.gridCellSize
                };
                break;
        }
        object.stop()
            .animate(animateOptions, 200, 'linear', function () {
            _this.calculateZindex(object);
            if (typeof callback === 'function') {
                callback();
            }
        });
    };
    Game.prototype.preload = function () {
        var _this = this;
        var items = [
            // Tile Map
            '../img/tile-map.gif',
            // Player
            '../img/rene-down.gif',
            '../img/rene-down-walking.gif',
            '../img/rene-left.gif',
            '../img/rene-left-walking.gif',
            '../img/rene-up.gif',
            '../img/rene-up-walking.gif',
            // NPC
            '../img/dude.gif',
            // Modals
            '../img/modal-border.gif',
            // Emotes
            '../img/emote-happiness.gif',
            '../img/emote-love.gif',
            '../img/emote-question.gif',
            '../img/emote-sadness.gif',
            '../img/emote-talk-angry.gif',
            '../img/emote-talk-happy.gif',
            '../img/emote-think.gif',
            // Icons
            '../img/icon-continue.gif'
        ];
        var outstanding = items.length;
        this.preloading = true;
        if (!this.loadingDiv) {
            this.loadingDiv = this.loadingMessage.clone();
            this.bodyDiv.append(this.loadingDiv);
        }
        for (var i = 0; i < items.length; i++) {
            this.loading = true;
            $.ajax({
                type: 'GET',
                url: items[i]
            }).done(function () {
                // Do nothing
            }).fail(function () {
                // Do nothing
            }).always(function () {
                outstanding--;
                if (outstanding === 0) {
                    _this.preloading = false;
                    _this.start();
                }
            });
        }
    };
    Game.prototype.start = function () {
        // setInterval(() => {
        //     this.update();
        // }, 1000 / this.fps);
        var _this = this;
        var _update = function () {
            _this.update();
            requestAnimationFrame(_update);
        };
        _update();
        stage.init('a000');
    };
    Game.prototype.update = function () {
        if (this.loading) {
            if (!this.loadingDiv) {
                this.loadingDiv = this.loadingMessage.clone();
                this.bodyDiv.append(this.loadingDiv);
            }
        }
        else {
            if (this.loadingDiv) {
                this.loadingDiv.remove();
                this.loadingDiv = undefined;
            }
            if (this.activeModal) {
                this.activeModal.data('modal').checkButtons();
            }
            if (this.activePlayer) {
                this.activePlayer.data('player').checkButtons();
            }
        }
    };
    return Game;
})();
var game = new Game();
/** BINDINGS **/
$(document).on('keydown', function (event) {
    event.preventDefault();
    game.pressedKeys[event.which] = true;
});
$(document).on('keyup', function (event) {
    event.preventDefault();
    game.pressedKeys[event.which] = false;
    if (game.activeModal) {
        game.activeModal.data('modal').allowPress = true;
    }
    if (game.activePlayer) {
        game.activePlayer.data('player').allowPress = true;
    }
});
/** GAME START! **/
$(document).on('ready', function () {
    game.init();
});
var music = {
    'shadesOfRed': {
        text: '<a href="http://ocremix.org/remix/OCR02216" target="_blank">Shades of Red, by halc</a>'
    },
    'wetDreams': {
        text: '<a href="http://ocremix.org/remix/OCR02727" target="_blank">Wet Dreams, by Phonetic Hero</a>'
    }
};
